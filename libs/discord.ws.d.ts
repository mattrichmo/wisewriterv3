import { MJConfig, MJMessage, LoadingHandler, MJEmit, MJInfo, MJSettings, MJOptions, OnModal, MJShorten } from "./interfaces";
import { MidjourneyApi } from "./midjourne.api";
import WebSocket from "isomorphic-ws";
export declare class WsMessage {
    config: MJConfig;
    MJApi: MidjourneyApi;
    ws: WebSocket;
    private closed;
    private event;
    private waitMjEvents;
    private skipMessageId;
    private reconnectTime;
    private heartbeatInterval;
    UserId: string;
    constructor(config: MJConfig, MJApi: MidjourneyApi);
    private heartbeat;
    close(): void;
    private reconnect;
    private open;
    private auth;
    timeout(ms: number): Promise<unknown>;
    private messageCreate;
    private messageUpdate;
    private onInteractionSuccess;
    private onReady;
    private onMessageCreate;
    private onMessageUpdate;
    private parseMessage;
    private verifyHuman;
    private EventError;
    private done;
    private processingImage;
    private filterMessages;
    private getEventByContent;
    private getEventById;
    private getEventByNonce;
    private updateMjEventIdByNonce;
    protected log(...args: any[]): Promise<void>;
    emit(event: string, message: any): void;
    private emitImage;
    private emitMJ;
    on(event: string, callback: (message: any) => void): void;
    onSystem(event: "ready" | "messageCreate" | "messageUpdate" | "interactionSuccess", callback: (message: any) => void): void;
    private emitSystem;
    once(event: string, callback: (message: any) => void): void;
    remove(event: string, callback: (message: any) => void): void;
    removeEvent(event: string): void;
    onceInfo(callback: (message: any) => void): void;
    onceSettings(callback: (message: any) => void): void;
    onceMJ(nonce: string, callback: (data: any) => void): void;
    private removeSkipMessageId;
    private removeWaitMjEvent;
    onceImage(nonce: string, callback: (data: MJEmit) => void): void;
    waitImageMessage({ nonce, prompt, onmodal, messageId, loading, }: {
        nonce: string;
        prompt?: string;
        messageId?: string;
        onmodal?: OnModal;
        loading?: LoadingHandler;
    }): Promise<MJMessage | null>;
    waitDescribe(nonce: string): Promise<{
        options: MJOptions[];
        descriptions: string[];
    } | null>;
    waitShorten(nonce: string): Promise<MJShorten | null>;
    waitContent(event: string): Promise<string | null>;
    waitInfo(): Promise<MJInfo | null>;
    waitSettings(): Promise<MJSettings | null>;
}
